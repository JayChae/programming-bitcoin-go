<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
    <link
      rel="stylesheet"
      as="style"
      crossorigin
      href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css"
    />
    <link
      rel="stylesheet"
      as="style"
      crossorigin
      href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/variable/pretendardvariable-dynamic-subset.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css"
    />

    <title>Chapter 1: Finite Fields</title>
  </head>
  <body style="font-family: Pretendard Variable">
    <article>
      <h1>Chapter 1: Finite Fields</h1>
      <p class="author">
        Ivar <br />
        October 20, 2025 <br />
        <a href="./index.html">한국어</a>
      </p>

      <div class="abstract">
        <h2>Abstract</h2>
        <p>
          We will understand finite fields, a mathematical concept that forms
          the foundation of elliptic curve cryptography used for Bitcoin
          signatures and verification, and implement finite field operations in
          Go.
        </p>
      </div>

      <h2>Definition of Finite Fields</h2>
      <p>
        A finite field is a set with a finite number of elements that satisfies
        the following properties:
      </p>
      <ol>
        <li>
          If a and b are in the set, then a+b and a*b are also in the set (the
          set is closed under addition and multiplication)
        </li>
        <li>
          There exists an element in the set denoted by 0 such that for any
          element a in the set, a + 0 = a (additive identity exists)
        </li>
        <li>
          There exists an element in the set denoted by 1 such that for any
          element a in the set, a * 1 = a (multiplicative identity exists)
        </li>
        <li>
          For any element a in the set, there exists an element b in the set
          such that a + b = 0, and we denote this b as -a (additive inverse
          exists)
        </li>
        <li>
          For any non-zero element a in the set, there exists an element b in
          the set such that a * b = 1, and we denote this b as a<sup>-1</sup>
          (multiplicative inverse exists)
        </li>
      </ol>
      <p>
        The number of elements in a finite field is called its order. We denote
        the order as p, and p is a prime number.
      </p>

      <h2>Defining Finite Sets</h2>
      <p>
        If the order of a set is p, then the elements of the set can be written
        as 0, 1, 2, ... p-1 and denoted as follows:
      </p>
      <p>F<sub>p</sub> = { 0, 1, 2, ... p-1 }</p>
      <p>
        The order (p) of a finite field is always one more than the largest
        numeric element (p-1). Also, a finite field must have an order that is
        either a prime number or a power of a prime number.
      </p>

      <h2>Modulo Arithmetic</h2>
      <p>
        According to the definition of finite fields, finite fields must be
        closed under addition, multiplication, subtraction (additive inverse),
        and division (multiplicative inverse)
        <label for="sn-1" class="sidenote-toggle sidenote-number"></label>
        <input type="checkbox" id="sn-1" class="sidenote-toggle" />
        <span class="sidenote">
          Being closed means that the result of the operation is also within the
          set.
        </span>
        .
      </p>
      <p>
        To implement finite fields using a limited range of values, we use
        modulo arithmetic. No matter how large a number is, applying modulo
        arithmetic converts it to a small range of numbers. For example, when
        performing modulo 12 arithmetic, no matter how large a number is, it is
        converted to a number between 0 and 11. This is similar to how no matter
        how much time passes, a clock hand always points to a number between 0
        and 11.
      </p>

      <h2>Finite Field Operations Definition</h2>
      <sub>f</sub> is a notation to distinguish finite field operations from
      ordinary integer operations.
      <h3>Addition</h3>
      <p>
        Addition calculates the sum of two elements and performs modulo p
        operation.
      </p>
      <p>a +<sub>f</sub> b = (a + b) % p</p>

      <h3>Subtraction</h3>
      <p>
        Subtraction calculates the difference of two elements and performs
        modulo p operation.
      </p>
      <p>a -<sub>f</sub> b = (a - b) mod p</p>

      <h3>Additive Inverse</h3>
      <p>
        Additive inverse calculates the inverse of an element and performs
        modulo p operation.
      </p>
      <p>-a<sub>f</sub> = (-a) % p</p>

      <h3>Multiplication</h3>
      <p>
        Multiplication calculates the product of two elements and performs
        modulo p operation.
      </p>
      <p>a *<sub>f</sub> b = (a * b) % p</p>

      <h3>Exponentiation</h3>
      <p>
        Exponentiation multiplies an element multiple times and performs modulo
        p operation.
      </p>
      <p>a<sup>b</sup> = (a<sup>b</sup>) % p</p>

      <h3>Division</h3>
      <h4>Fermat's Little Theorem</h4>
      <p>
        Fermat's Little Theorem satisfies the following property for a prime
        number p:
      </p>
      <p>n<sup>(p-1)</sup> % p = 1</p>
      <p>
        Using this, we can convert division to multiplication.
        <label for="sn-2" class="sidenote-toggle sidenote-number"></label>
        <input type="checkbox" id="sn-2" class="sidenote-toggle" />
        <span class="sidenote">
          According to Fermat's Little Theorem, b<sup>(p-1)</sup> = 1 = b<sup
            >-1</sup
          >
          * 1, so b<sup>-1</sup> * b<sup>(p-1)</sup> = b<sup>(p-2)</sup>,
          therefore b<sup>-1</sup> = b<sup>(p-2)</sup>
        </span>
      </p>
      <p>a / b = a * b<sup>-1</sup> = a * b<sup>(p-2)</sup></p>

      <h2>Implementing Finite Field Operations in Go</h2>

      <h3>1. Field Element Definition</h3>
      <p>
        Define a struct to represent finite field elements. Each element has a
        value (num) and a prime number (prime).
      </p>
      <pre><code class="language-go">// Struct representing a finite field element
type FieldElement struct {
    num   int
    prime int
}</code></pre>

      <h3>2. Field Element Constructor</h3>
      <p>
        Function to create finite field elements. Returns an error if the value
        is outside the finite field range (0 ≤ num < prime).
      </p>
      <pre><code class="language-go">// Create finite field element
func NewFieldElement(num, prime int) (*FieldElement, error) {
    if num >= prime || num < 0 {
        return nil, fmt.Errorf("num %d not in field range 0 to %d", num, prime-1)
    }
    return &FieldElement{num, prime}, nil
}</code></pre>

      <h3>3. String Representation</h3>
      <p>Method to output finite field elements as strings.</p>
      <pre><code class="language-go">// Function to return finite field element as string
func (f *FieldElement) String() string {
    return fmt.Sprintf("FieldElement_%d(%d)", f.prime, f.num)
}</code></pre>

      <h3>4. Equality Check</h3>
      <p>Method to check if two finite field elements are equal.</p>
      <pre><code class="language-go">// Function to check if finite field elements are equal
func (f *FieldElement) Equals(other *FieldElement) bool {
    return f.num == other.num && f.prime == other.prime
}</code></pre>

      <h3>5. Addition Operation</h3>
      <p>
        Method to add two finite field elements. They must belong to the same
        finite field.
      </p>
      <pre><code class="language-go">// Finite field element addition
func (f *FieldElement) Add(other *FieldElement) (*FieldElement, error) {
    if f.prime != other.prime {
        return nil, fmt.Errorf("cannot add two numbers in different Fields %d, %d", f.prime, other.prime)
    }
    num := (f.num + other.num) % f.prime
    return NewFieldElement(num, f.prime)
}</code></pre>

      <h3>6. Subtraction Operation</h3>
      <p>
        Method to subtract two finite field elements. If the result is negative,
        we add the prime to make it positive.
      </p>
      <pre><code class="language-go">// Finite field element subtraction
func (f *FieldElement) Sub(other *FieldElement) (*FieldElement, error) {
    if f.prime != other.prime {
        return nil, fmt.Errorf("cannot add two numbers in different Fields %d, %d", f.prime, other.prime)
    }
    num := (f.num - other.num) % f.prime
    // Add prime if negative
    if num < 0 {
        num += f.prime
    }
    return NewFieldElement(num, f.prime)
}</code></pre>

      <h3>7. Multiplication Operation</h3>
      <p>Method to multiply two finite field elements.</p>
      <pre><code class="language-go">// Finite field element multiplication
func (f *FieldElement) Mul(other *FieldElement) (*FieldElement, error) {
    if f.prime != other.prime {
        return nil, fmt.Errorf("cannot add two numbers in different Fields %d, %d", f.prime, other.prime)
    }
    num := (f.num * other.num) % f.prime
    return NewFieldElement(num, f.prime)
}</code></pre>

      <h3>8. Exponentiation Operation</h3>
      <p>
        Method to calculate the exponentiation of finite field elements.
        Utilizes Fermat's Little Theorem.
      </p>
      <pre><code class="language-go">// Finite field element exponentiation
func (f *FieldElement) Pow(exp int) (*FieldElement, error) {
    exp %= (f.prime - 1)
    // Convert negative exponent to positive
    if exp < 0 {
        exp += (f.prime - 1)
    }
    num := pow(f.num, exp, f.prime) % f.prime
    return NewFieldElement(num, f.prime)
}</code></pre>

      <h3>9. Division Operation</h3>
      <p>
        Method to calculate division of finite field elements. Converts division
        to multiplication using Fermat's Little Theorem.
      </p>
      <pre><code class="language-go">// Finite field element division
func (f *FieldElement) Div(other *FieldElement) (*FieldElement, error) {
    if f.prime != other.prime {
        return nil, fmt.Errorf("cannot add two numbers in different Fields %d, %d", f.prime, other.prime)
    }
    // Convert division to multiplication using Fermat's Little Theorem
    num := (f.num * pow(other.num, f.prime-2, f.prime)) % f.prime
    return NewFieldElement(num, f.prime)
}</code></pre>

      <h3>10. Exponentiation Calculation Function</h3>
      <p>
        Efficient exponentiation calculation function using divide and conquer.
      </p>
      <pre><code class="language-go">// Function to calculate exponentiation (using divide and conquer)
func pow(num, exp, mod int) int {
    if exp == 0 {
        return 1
    }
    if exp == 1 {
        return num
    }
    if exp%2 == 0 {
        temp := pow(num, exp/2, mod)
        return (temp * temp) % mod
    }
    temp := pow(num, (exp-1)/2, mod)
    return (temp * temp * num) % mod
}</code></pre>

      <h3>11. Usage Example</h3>
      <p>Example of using the implemented finite field operations.</p>
      <pre><code class="language-go">func main() {
    a, _ := NewFieldElement(7, 13)
    b, _ := NewFieldElement(6, 13)

    fmt.Println(a.Equals(b))  // false
    fmt.Println(a.Equals(a))  // true

    c, _ := a.Add(b)          // FieldElement_13(0)
    fmt.Println(c)

    d, _ := a.Sub(b)          // FieldElement_13(1)
    fmt.Println(d)

    e, _ := a.Mul(b)          // FieldElement_13(3)
    fmt.Println(e)

    f, _ := a.Pow(-3)         // FieldElement_13(8)
    fmt.Println(f)

    g, _ := a.Div(b)          // FieldElement_13(12)
    fmt.Println(g)
}</code></pre>

      <div class="footnotes">
        <p>Sources of Reference and Inspiration</p>
        <p>
          <a
            href="https://www.oreilly.com/library/view/programming-bitcoin/9781492031482/"
          >
            Programming Bitcoin
          </a>
        </p>
        <p>
          <a href="https://github.com/piatoss3612/bitcoin-from-scratch">
            bitcoin-from-scratch
          </a>
        </p>
      </div>
    </article>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  </body>
</html>
